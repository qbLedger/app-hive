#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include <cmocka.h>
#include "transaction/transaction_parse.h"
#include "types.h"

static void test_transaction_parse_fail(void **state) {
    (void) state;

    uint8_t data[] = {0x05, 0x80, 0x00, 0x00, 0x30, 0x80, 0x00, 0x00, 0x0d, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x20,
                      0x18, 0xdc, 0xf0, 0xa2, 0x85, 0x36, 0x5f, 0xc5, 0x8b, 0x71, 0xf1, 0x8b, 0x3d, 0x3f, 0xec, 0x95, 0x4a, 0xa0, 0xc1, 0x41, 0xc4, 0x4e, 0x4e,
                      0x5c, 0xb4, 0xcf, 0x77, 0x7b, 0x9e, 0xab, 0x27, 0x4e, 0x04, 0x02, 0x52, 0x88, 0x04, 0x04, 0x9c, 0xe2, 0xcc, 0xea, 0x04, 0x04, 0x76, 0x60,
                      0xb8, 0x5e, 0x04, 0x01, 0x01, 0x04, 0x20, 0x00, 0x07, 0x65, 0x6e, 0x67, 0x72, 0x61, 0x76, 0x65, 0x07, 0x65, 0x6e, 0x67, 0x72, 0x61, 0x76,
                      0x65, 0x0c, 0x69, 0x6e, 0x74, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0xfa, 0xf6, 0x04, 0x01, 0x00};

    buffer_t valid_buffer = {.ptr = data, .size = sizeof(data), .offset = 0};

    // buffer too big
    valid_buffer.size = MAX_TRANSACTION_LEN + 1;
    assert_true(buffer_seek_set(&valid_buffer, 0));
    assert_int_equal(transaction_parse(&valid_buffer), WRONG_LENGTH_ERROR);

    // buffer too small, cannot read transaction length
    valid_buffer.size = 0;
    assert_true(buffer_seek_set(&valid_buffer, 0));
    assert_int_equal(transaction_parse(&valid_buffer), BIP32_PATH_PARSING_ERROR);

    // buffer too small, cannot read bip32 path
    valid_buffer.size = 5;
    assert_true(buffer_seek_set(&valid_buffer, 0));
    assert_int_equal(transaction_parse(&valid_buffer), BIP32_PATH_PARSING_ERROR);

    // buffer too small, cannot read chain id
    valid_buffer.size = 41;
    assert_true(buffer_seek_set(&valid_buffer, 0));
    assert_int_equal(transaction_parse(&valid_buffer), FIELD_PARSING_ERROR);
}

static void test_transaction_parse_success(void **state) {
    (void) state;

    uint8_t data[] = {0x05, 0x80, 0x00, 0x00, 0x30, 0x80, 0x00, 0x00, 0x0d, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x20,
                      0x18, 0xdc, 0xf0, 0xa2, 0x85, 0x36, 0x5f, 0xc5, 0x8b, 0x71, 0xf1, 0x8b, 0x3d, 0x3f, 0xec, 0x95, 0x4a, 0xa0, 0xc1, 0x41, 0xc4, 0x4e, 0x4e,
                      0x5c, 0xb4, 0xcf, 0x77, 0x7b, 0x9e, 0xab, 0x27, 0x4e, 0x04, 0x02, 0x52, 0x88, 0x04, 0x04, 0x9c, 0xe2, 0xcc, 0xea, 0x04, 0x04, 0x76, 0x60,
                      0xb8, 0x5e, 0x04, 0x01, 0x01, 0x04, 0x20, 0x00, 0x07, 0x65, 0x6e, 0x67, 0x72, 0x61, 0x76, 0x65, 0x07, 0x65, 0x6e, 0x67, 0x72, 0x61, 0x76,
                      0x65, 0x0c, 0x69, 0x6e, 0x74, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0xfa, 0xf6, 0x04, 0x01, 0x00};

    buffer_t valid_buffer = {.ptr = data, .size = sizeof(data), .offset = 0};

    for (uint8_t i = 0; i < 14; i++) {
        will_return(__wrap_cx_hash_no_throw, 0);
        will_return(__wrap_cx_hash_get_size, 0);

        // expect cx_hash to be called appropriate times
        expect_any(__wrap_cx_hash_no_throw, hash);
        expect_any(__wrap_cx_hash_no_throw, mode);
        expect_any(__wrap_cx_hash_no_throw, in);
        expect_any(__wrap_cx_hash_no_throw, len);
        expect_any(__wrap_cx_hash_no_throw, out);
        expect_any(__wrap_cx_hash_no_throw, out_len);
    }

    assert_int_equal(transaction_parse(&valid_buffer), PARSING_OK);
}

int main() {
    const struct CMUnitTest tests[] = {cmocka_unit_test(test_transaction_parse_fail), cmocka_unit_test(test_transaction_parse_success)};

    return cmocka_run_group_tests(tests, NULL, NULL);
}
